# Goorm Practice02

## 수행과제

-   ### DB 띄우기
    -   웹 서버와 연결할 mysql DB를 클러스터 상에 띄웁니다.
-   ### DB url을 환경변수로 주입하여 웹 서버 띄우기
    -   웹 서버 이미지를 사용하여 Deployment 형상을 작성합니다. 위에서 띄운 DB에 접근할 수 있도록 Deployment의 환경 변수로 DB url을 주입합니다.
    -   외부에서 접근할 수 있도록 Service와 Ingress를 생성합니다.

## 리소스 구조

ingress  
svc(spring)  
deploy(spring)  
svc(mysql)  
deploy(mysql)  
pvc,pv(mysql)

`본 과제는 GKE를 사용하여 구성되었다.`

## DB 띄우기

Spring App은 Database에 의존성을 가지므로 어플리케이션을 실행려면 선제적으로 DB를 구성해야한다. 데이터베이스가 구성되려면 다음 요소들이 필요하다.

-   영구저장소
-   mysql app

이를 k8s의 컴포넌트들로 구성하기 위해서는 다음과 같이 책임을 분리하였다.

### 책임

-   PV
    > mysql의 데이터가 저장될 수 있는 물리 저장소를 추상화 시킨다.
-   PVC
    > container의 볼륨이 마운트 될 수 있는 pv를 요청 및 탐색한다.
-   Deploy
    > mysql app이 실행될 컨테이너를 관리한다.
-   SVC
    > mysql pod이 내부 시스템에서 사용될 수 있도록 export시킨다.

## 웹 서버 띄우기

Spring app과 이전 단계에서 제작한 mysql app이 연결되어야 한다. 이때 Spring app과 연결되는 database 정보를 `.properties`에 입력하는 것이 아닌 `template`의 env 사양으로 등록하여 유동적으로 변경이 가능하게 해야한다.  
spring app을 외부로 노출시킬 때 포트포워딩이 아닌 ingress를 생성하여 svc와 연결한다.

이를 k8s의 컴포넌트들로 구성하기 위해서는 다음과 같이 책임을 분리하였다.

### 책임

-   Deploy
    > spring app이 실행될 컨테이너를 관리한다.
-   SVC
    > spring pod이 내부 시스템에서 사용될 수 있도록 export시킨다.
-   Ingress
    > 특정 규칙에 따라, 외부 트래픽을 내부 pod과 연결시켜준다.

이를 위해 컴포넌트들을 구성하다 생긴 의문점들과 사고해야하는 부분이 몇 가지 있었다.

### 신경썼던 부분

-   deploy 생성시 `replica`의 개수

    > 복제 개수를 몇 개를 설정할지 고민을 하였었다. 기본적으로는 1개지만 서버의 안정성을 위하여 3개 이상의 pod을 만드는 경우도 흔하였기 때문이다.  
    > 우선은 1개의 replica를 선택하였다. 사용자의 트래픽을 분할할 필요도 없고, pod의 생명주기가 연속적이여야 하거나, pod의 다운이 서비스에 문제을 일으키지 않는 상황이기에 복제본의 효과가 딱히 없다 판단하였다.

-   PV의 `Permission`은 어떤 것을 주어야 하는가?

    > DB가 사용할 볼륨이므로, `ReadWrite` 두 권한 모두 주어지는 것까지는 결정하였다. 문제는 `Once`와 `Many`중 선택하는 것이였다.
    > Once는 하나의 노드에서만 접근이 가능하고, Many는 복수의 노드에서 동시에 접속할 수 있는 권한이다. 저장되는 데이터의 정합성, 트랜잭션을 보장하기 위해서는 Once로 설정하는 것이 옳은 것 같다. 당시에 과제를 작성할 때는 복수의 pod이 해당 disk를 사용하게 된다면? 이라는 생각으로 Many로 지정하였다. 하지만 다시 설계를 한다면 `ReadWriteOnce`로 설정할 것이다.

-   `ConfigMap`과 `Secret`설정은 어떻게 해야하는가?
    > 과제 01을 해결하며 알았던 사실중에 spring app의 `.properties`가 환경변수를 지정한다는 사실을 알았다. 이 방법을 사용하여 mysql의 계정 설정과, spring과의 연결을 설정할 것이다. 이때 고려한 부분은 password가 `.yaml`에 포함되어도 되는가? 였다. 이미지는 누구든 내려받아 빌드된 파일을 열어볼 수 있기때문에 보안상 부적절하기에 해당 설정을 k8s의 secret 기능을 사용하였다. 다만 BASE64형태로 인코딩하는 것이 표준이라는 것과, setup script에 해당 값이 포함되게 된다면, 보안으로서의 의미가 퇴색되므로 어떻게 보안을 지켜 password를 부여하는 작업까지 자동화 시킬수 있는지 고민하게되었다.

### 의문점

#### PV, PVC

-   [[k8s 볼륨 문서]](https://kubernetes.io/ko/docs/concepts/storage/volumes/) 해당 문서에 따르면 `gcePersistentDisk (사용 중단됨)`이라는 항목이 존재한다. gce상에서 mysql의 영구 저장소를 위하여 GPD를 사용하였는데, 왜 중단된 것일까?

    > k8s는 다양한 외부 영구 저장소와의 유기적인 연결과, 각 시스템에 대한 의존성을 피하기 위하여 인터페이스를 정의하고 해당 방식으로 연결하는 방식을 택하게 되었다. 이를 `Container Storage Interface (CSI)`라 하며 GPD도 해당 시스템을 사용하여 연결하여 사용하는 것을 권장하고 있다.

-   PV와 PVC를 사용할 때 실제 디스크 공간은 어떻게 할당이 되는 것인가?

    > PV는 사용할 수 있는 디스크 공간을 '할당 받는 것'이 아닌 '사용할 수 있음'을 나타내는 정보를 가지는 역할을 한다. 실제로 디스크 공간이 할당되는 시점은 발행된 PVC와 PV가 연결되는 시점이다. 이때 물리 디스크가 완벽하게 격리되는가? 그것은 아니였다. 설정에 따라 다르기도 하다. 완벽하게 격리되는 시나리오와 오버 커밋이 가능한 시나리오 전부 설정이 가능하였다. 의도에 맞게 공간을 설계해야하는 것이다.

-   PVC를 사용하는 장점은 무엇일까? 정적 프로비저닝을 사용한다면, PV 제작후 개발자에게 PV정보를 제공하여야 한다. 그렇다면 인프라 환경과 개발환경이 온전히 격리되는 것은 아니지 않나?
    > 저장 공간과의 완벽한 격리를 위한 시스템은 아니였다. 실제 물리 디스크의 크기와 접근할 수 있는 disk host의 주소나 위치, 버전 정보등을 개발자에게서 분리시킬 수 있다는 것이었다. PV와 PVC를 사용하는 것을 통하여 개발자는 오로지 권한과 저장 용량에만 관심사를 가질 수 있게 되는 것이다.

#### SVC

-   ClusterIP와 Port-Forward의 차이는 무엇인가? pod의 포트를 노출시킨 다는 기능이외의 차이는 무엇인가?

    > 기본적으로 노출 범위의 차이가 있다. `ClusterIP`는 클러스터 내부에서만 접근할 수 있는 내부 ip주소를 제공한다. 이 내부ip주소는 클러스터의 DNS 특정 `svc-name.name-space.svc.cluster.local`이라는 규칙을 통하여 내부 domain을 가지게된다. 이를 통하여 cluster의 내부 시스템에서 svc(pod)에 대한 접근을 시스템적인 구조로 접근할 수 있게 된다. 반면 `Port-Forward`는 pod의 특정 프로세스를 작동중인 로컬머신의 포트로 노출시켜, 외부에서의 접근도 허용한다. 이를통해 서비스 계층없이 특정 pod의 프로세스를 사용할 수 있지만, 내부시스템에서 해당 프로세스와 관계를 가지고자 하는 경우 `내부 <-> 내부`가 아닌 `내부 -> 외부 -> 내부` 라는 네트워크 흐름을 가지게 되어 효율성 및 보안에 문제가 생긴다.

    -   그렇다면 `ExternalName`의 올바른 이해는 무엇일까? 단순하게 외부시스템을 k8s에서 사용할 수 있게 하는 것. 잘못된 말은 아니지만 이는 의문을 가지게 된다. 클러스터 내부에서 외부 시스템의 host를 알고 있다면, 그냥 사용하면 그만이다. 그럼에도 `ExternalName`이라는 기능은 무엇을 위한 것인가?
        > `ExternalNamed` 서비스를 생성하면 외부 시스템의 host가 서비스라는 내부 시스템으로 변환된다. dns에 cname과 svc domain을 연결하기 때문이다. 이후 클러스터 구조를 작성할 때 k8s의 서비스가 가질 수 있는 여러 설정들을 외부시스템에도 적용시킬 수 있다. 이제는 `ExternalNamed` 서비스 객체가 되었기 때문이다. 또한 서비스 객체로 추상화가 되었으므로, 외부 시스템이 변경되었을 때 svc 설정만 수정하면 되는 장점을 가지게 된다.

#### Deploy

-   `pod`의 사양을 deploy에 기록하고, 여러 pod을 운용한다. 이는 `RS`과는 어떠한 차이를 가지는가?
    > Deploy를 통하여 pod을 생성할 때, 바로 pod이 만들어지지 않는다. deploy는 RS를 생성하고 RS가 pod을 생성하고 관리하게 된다. 즉 여전히 pod에 대한 관리라는 책임은 RS가 가지는 것이다. Deploy는 이러한 RS를 설정하고 관리하는 책임을 가져 간접적으로 pod을 관리하는 것이다. yaml만 보았을 때는 혼동이 생길 수 있지만 분명하게 책임이 분리되어 있었다.
